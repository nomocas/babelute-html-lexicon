(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Babelute = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Babelute = require('babelute'); // core
require('../lib/html'); // html dsl lexicon
var dif = require('../lib/pragmatics/html-to-dom-diffing'); // dom diffing
module.exports = {
	Babelute: Babelute,
	htmlToDomDiffing: dif
};
},{"../lib/html":2,"../lib/pragmatics/html-to-dom-diffing":3,"babelute":4}],2:[function(require,module,exports){
/**
 * ***** Babelute HTML5 DSL lexicon *****
 *
 * 
 * @author Gilles Coomans
 * @licence MIT
 * @copyright 2016-2017 Gilles Coomans
 */

var Babelute = require('babelute');

/*******
 *******	LANGUAGE ATOMS (simply enqueueing lexems)
 *******/
Babelute.toLexic('html', ['tag', 'attr', 'prop', 'data', 'class', 'id', 'text', 'on']);

/*******
 *******	COMPOUNDS WORDS (based on language atoms)
 *******/
// simple tags (made with .tag) (list should be completed)
var tagsList = ['div', 'h1', 'h2', 'h3', 'section', 'span', 'button', 'article', 'hr', 'header', 'footer', 'label', 'ul', 'li', 'p', 'small', 'b', 'strong', 'i', 'u', 'select'];
tagsList.forEach(function(tagName) {
	Babelute.toLexic('html', tagName, function() {
		return this.tag(tagName, arguments);
	});
});

// events (made with .on) (list should be completed)
var eventsList = ['click', 'mouseover', 'keyup'];
eventsList.forEach(function(eventName) {
	Babelute.toLexic('html', eventName, function(callback) {
		return this.on(eventName, callback);
	});
});

// compounds tags (made with other lexems)
var h = Babelute.initializer('html');
Babelute.toLexic('html', {
	a: function(href, content) {
		return this.tag('a', [h.attr('href', href), content]);
	},
	input: function(type, val, babelute) {
		return this.tag('input', [h.attr('type', type).attr('value', val), babelute]);
	},
	textInput: function(val, babelute) {
		return this.input('text', val, babelute);
	},
	passwordInput: function(val, babelute) {
		return this.input('password', val, babelute);
	},
	checkbox: function(checked, babelute) {
		return this.tag('input', [h.attr('type', 'checkbox').prop('checked', !!checked), babelute]);
	},
	radio: function(checked, babelute) {
		return this.tag('input', [h.attr('type', 'radio').prop('checked', !!checked), babelute]);
	},
	option: function(value, content) {
		return this.tag('option', [h.attr('value', value), content]);
	},
	visible: function(yes) {
		return this.prop('visibility', !!yes ? 'visible' : 'hidden');
	}
});

module.exports = Babelute;

/**
 * Small First degree optimisation (bypass inner degrees developement) (don't look if you're new with babelute ;))
 * Optional.
 */
var lexic = Babelute.getLexic('html');
// small first degree optimisation (bypass .tag(._append()))
tagsList.forEach(function(name) {
	lexic.FirstDegree.prototype[name] = function() {
		this._lexems.push(new Babelute.Lexem('html', 'tag', [name, arguments]));
		return this;
	};
});
// small first degree optimisation (bypass .on(._append()))
eventsList.forEach(function(eventName) {
	lexic.FirstDegree.prototype[name] = function(handler, argument) {
		this._lexems.push(new Babelute.Lexem('html', 'on', [eventName, handler, argument]));
		return this;
	};
});

// => so 26 words defined in the lexic for the moment.
// tag, attr, prop, data, class, id, text, on, click, mouseover, keyUp, div, h1, h2, h3, section, article, span, button, a, select, option, strong, onHtmlString, onHtmlDom
//
},{"babelute":4}],3:[function(require,module,exports){
/**
 * ****** First Degree AST diffing ******
 * 
 * Algorithmic performance always depends on input set. Bigger set is : bigger optimisations should appear.
 * For this reason, good algorithmic optimisations works by cutting logical tree as high as possible.
 * This one works on the highest avaiable tree : the template's AST.
 * And it works by developping render-functions degree by degree, only when needed.
 * It allows to keep rendering perf incredibly stable through sequence of modifications.
 * More you have components, more you have nodes, better optimisations you have.
 *
 * @author Gilles Coomans
 * @licence MIT
 * @copyright 2016-2017 Gilles Coomans
 */

require('../html');
var Babelute = require('babelute/lib/babelute'),
	h = Babelute.initializer('html'), // only needed for .text() in tag's children
	_targetLexics = {
		default: true,
		html: true
	};

//______________________________________________ RENDER STRATEGY

var renderActions = {
	// Atoms rendering
	class: function($tag, lexem) {
		var args = lexem.args; /* className */
		if (args[0] && (args.length === 1 || args[1]))
			$tag.classList.add(args[0]);
	},
	attr: function($tag, lexem) {
		var args = lexem.args; /* name, value */
		$tag.setAttribute(args[0], args[1]);
	},
	prop: function($tag, lexem) {
		var args = lexem.args; /* name, value */
		$tag[args[0]] = args[1];
	},
	data: function($tag, lexem) {
		var args = lexem.args; /* name, value */
		$tag.dataSet[args[0]] = args[1];
	},
	id: function($tag, lexem) {
		var args = lexem.args; /* value */
		$tag.id = args[0];
	},
	on: function($tag, lexem) {
		var args = lexem.args; /* eventName, callback */
		$tag.addEventListener(args[0], args[1]);
	},

	// structural render actions
	tag: function($tag, lexem, env, frag) {
		lexem.child = document.createElement(lexem.args[0]);
		(frag || $tag).appendChild(lexem.child);
		var babelutes = lexem.args[1],
			babelute;
		for (var i = 0, len = babelutes.length; i < len; ++i) {
			babelute = babelutes[i];
			if (typeof babelute === 'undefined') // cast undefined to '' to keep track of node for diffing
				babelute = '';
			if (!babelute || !babelute.__babelute__) // text node
				babelute = babelutes[i] = h.text(babelute);
			render(lexem.child, babelute, env);
		}
	},

	text: function($tag, lexem, env, frag) {
		lexem.child = document.createTextNode(lexem.args[0]);
		(frag || $tag).appendChild(lexem.child);
	},

	if: function($tag, lexem, env, frag) {
		var toRender = lexem.args[0] ? lexem.args[1] : (lexem.args[2] ? lexem.args[2] : null);
		if (toRender) {
			render($tag, toRender, env, frag);
			lexem.developped = toRender;
		}
		lexem.witness = document.createComment('if');
		$tag.appendChild(lexem.witness);
	},

	each: function($tag, lexem, env, frag) {
		var args = lexem.args;
		lexem.children = [];
		var collection = args[0] = args[0] ||  [],
			itemRender = args[1],
			item;
		for (var i = 0, len = collection.length; i < len; ++i) {
			var rendered = itemRender(collection[i]);
			lexem.children.push(rendered);
			render($tag, rendered, env, frag);
		}
		lexem.witness = document.createComment('each');
		$tag.appendChild(lexem.witness);
	},

	// custom output
	onDom: function($tag, lexem, env, frag /* args = render, dif, remove */ ) {
		var onRender = lexem.args[0];
		if (onRender)
			onRender($tag, lexem, env, frag);
	},
	onString: function(descriptor, lexem, env /* render */ ) {
		var onRender = lexem.args[0];
		if (onRender)
			onRender(descriptor, lexem, env);
	}
};

function render($tag, babelute, env, frag) {
	for (var i = 0, action, lexem, lexems = babelute._lexems, len = lexems.length; i < len; ++i) {
		lexem = lexems[i];
		if (!_targetLexics[lexem.lexic])
			continue;
		action = renderActions[lexem.name];
		if (action)
			action($tag, lexem, env, frag);
		else // no actions means it's a compound lexem : so recursion on first degree dev.
			render($tag, Babelute.expandOneDegreeLexem(lexem), env, frag);
	}
}

//______________________________________________ DIF STRATEGY

var difActions = {
	// structurals
	if: function($tag, lexem, olexem, env) {
		lexem.witness = olexem.witness;
		var args = lexem.args,
			oargs = olexem.args,
			toRender;
		if (!args[0] !== !oargs[0]) { // condition has change
			if (args[0]) { // new condition is true
				if (oargs[2]) // has old rendered "else" : remove it
					remove($tag, oargs[2], env);
				toRender = args[1]; // render "success" babelute
			} else { // new condition is false
				remove($tag, oargs[1], env); // remove "success" babelute
				toRender = args[2]; // try render "else" babelute
			}
			if (toRender) {
				var frag = document.createDocumentFragment();
				lexem.developped = toRender;
				render($tag, toRender, env, frag);
				$tag.insertBefore(frag, lexem.witness);
			}
		} else if (args[0]) { // no change and condition is true
			lexem.developped = args[1];
			dif($tag, args[1], oargs[1], env);
		} else if (args[2]) { // no change and condition is false and there is a "else" babelute to render (third argument of .if call)
			lexem.developped = args[2];
			dif($tag, args[2], oargs[2], env);
		}
	},

	each: function($tag, lexem, olexem, env) {
		var collection = lexem.args[0],
			renderItem = lexem.args[1],
			ochildren = olexem.children,
			len = collection.length,
			olen = ochildren.length,
			children = lexem.children = [],
			rendered,
			frag,
			i = 0;

		lexem.witness = olexem.witness; // keep track of witness
		if (len > olen) // create fragment for new items
			frag = document.createDocumentFragment();
		for (; i < len; ++i) { // for all items (from new lexem)
			rendered = renderItem(collection[i]); // render firstdegree item
			children.push(rendered); // keep new rendered
			if (i < olen) // dif existing children
				dif($tag, rendered, ochildren[i], env);
			else // full render new item and place produced tags in fragment 
				render($tag, rendered, env, frag); // ($tag is forwarded for first level non-tags atoms lexems (aka class, attr, ...))
		}
		for (; i < olen; ++i) // remove not diffed old children
			remove($tag, ochildren[i], env);
		if (frag) // insert new children fragment (if any)
			$tag.insertBefore(frag, lexem.witness);
	},

	tag: function($tag, lexem, olexem, env) {
		lexem.child = olexem.child; // keep track of elementNode
		var babelutes = lexem.args[1],
			obabelutes = olexem.args[1],
			babelute, obabelute;
		for (var i = 0, len = babelutes.length; i < len; i++) {
			// render all children's babelutes
			babelute = babelutes[i];
			obabelute = obabelutes[i];
			if (babelute === obabelute)
				continue;
			if (typeof babelute === 'undefined') // cast undefined to empty string
				babelute = '';
			if (!babelute || !babelute.__babelute__)
				babelute = babelutes[i] = h.text(babelute);
			dif(lexem.child, babelute, obabelute, env);
		}
	},

	text: function($tag, lexem, olexem) {
		lexem.child = olexem.child; // keep track of textnode
		if (lexem.args[0] !== olexem.args[0])
			lexem.child.nodeValue = lexem.args[0];
	},

	// html simple atoms diffing
	class: function($tag, lexem, olexem) {
		var name = lexem.args[0], // new class name
			oname = olexem.args[0], // old class name
			flag = lexem.args[1], // new class flag
			oflag = olexem.args[1]; // old class flag
		if (name !== oname) {
			if (oname)
				$tag.classList.remove(oname);
			if (name && (lexem.args.length === 1 || flag))
				$tag.classList.add(name);
		} else if (name && lexem.args.length > 1 && !flag !== !oflag)
			$tag.classList.toggle(name);
	},

	attr: function($tag, lexem, olexem) {
		if (lexem.args[0] !== olexem.args[0]) {
			$tag.removeAttribute(olexem.args[0]);
			$tag.setAttribute(lexem.args[0], lexem.args[1]);
		} else if (lexem.args[1] !== olexem.args[1])
			$tag.setAttribute(lexem.args[0], lexem.args[1]);
	},

	prop: function($tag, lexem, olexem) {
		if (lexem.args[0] !== olexem.args[0]) {
			delete $tag[olexem.args[0]];
			$tag[lexem.args[0]] = lexem.args[1];
		} else if (lexem.args[1] !== $tag[lexem.args[0]] /*olexem.args[1]*/ ) // look diectly in element : for "checked" bug (or other properties that change on native interaction with element)
			$tag[lexem.args[0]] = lexem.args[1];
	},

	data: function($tag, lexem, olexem) {
		if (lexem.args[0] !== olexem.args[0]) {
			delete $tag.dataSet[olexem.args[0]];
			$tag.dataSet[lexem.args[0]] = lexem.args[1];
		} else if (lexem.args[1] !== olexem.args[1])
			$tag.dataSet[lexem.args[0]] = lexem.args[1];
	},

	id: function($tag, lexem, olexem) {
		if (lexem.args[0] !== olexem.args[0])
			$tag.id = lexem.args[0];
	},

	on: function($tag, lexem, olexem) {
		if (lexem.args[0] !== olexem.args[0] || lexem.args[1] !== olexem.args[1]) {
			$tag.removeEventListener(olexem.args[0], olexem.args[1]);
			$tag.addEventListener(lexem.args[0], lexem.args[1]);
		}
	},

	onDom: function($tag, lexem, olexem /* args = render, dif, remove */ ) {
		var dif = lexem.args[1];
		if (dif)
			dif($tag, lexem, olexem);
	}
};

function dif($tag, babelute, oldb, env) {
	for (var lexem, olexem, action, i = 0, len = babelute._lexems.length; i < len; ++i) {
		lexem = babelute._lexems[i];
		if (!_targetLexics[lexem.lexic])
			continue;
		olexem = oldb._lexems[i];
		if (!lexem.args.length) // wathever lexem is : no args implies never change, so keep old rendered
			lexem.developped = olexem.developped;
		else {
			action = difActions[lexem.name]; // structural or atom diffing action
			if (action) // let strategy action do the job
				action($tag, lexem, olexem, env);
			else if (argsChanged(lexem.args, olexem.args, env)) // no action means compounds first degree lexem. so check args dif...
				dif($tag, Babelute.expandOneDegreeLexem(lexem), olexem.developped, env);
			else // keep old rendered (compounds args haven't changed : so nothing to do)
				lexem.developped = olexem.developped;
		}
	}
}

function argsChanged(args, oargs, env) {
	for (var i = 0, len = args.length; i < len; ++i)
		if (args[i] !== oargs[i]) // simple reference check : need immutables
			return true;
	return false;
}

//______________________________________________ REMOVE STRATEGY

var removeActions = {
	attr: function($tag, lexem) {
		$tag.removeAttribute(lexem.args[0]);
	},
	class: function($tag, lexem) {
		if (lexem.args[0])
			$tag.classList.remove(lexem.args[0]);
	},
	prop: function($tag, lexem) {
		delete $tag[lexem.args[0]];
	},
	data: function($tag, lexem) {
		delete $tag.dataSet[lexem.args[0]];
	},
	id: function($tag, lexem) {
		delete $tag.id;
	},
	on: function($tag, lexem) {
		$tag.removeEventListener(lexem.args[0], lexem.listener || lexem.args[1]);
	},
	each: function($tag, lexem) {
		lexem.children.forEach(function(child) {
			remove($tag, child, env);
		});
	},
	onDom: function($tag, lexem /* render, dif, remove */ ) {
		var remove = lexem.args[2];
		if (remove)
			remove($tag, lexem);
	}
};

function remove($tag, babelute, env) {
	for (var i = 0, lexems = babelute._lexems, lexem, action, len = lexems.length; i < len; ++i) {
		lexem = lexems[i];
		if (!_targetLexics[lexem.lexic])
			continue;
		if (action = removeActions[lexem.name]) // class, attr, id, prop, data, each, and .on
			action($tag, lexem, env);
		else if (lexem.developped) { // compounds and if
			remove($tag, lexem.developped, env);
			lexem.developped = null;
		} else if (lexem.child) { // tag and text
			$tag.removeChild(lexem.child);
			lexem.child = null;
		}
		if (lexem.witness) // view, if, each
			$tag.removeChild(lexem.witness);
	}
}

//______________________________________________

// exports babelute-pragmatics Object
module.exports = {
	_targetLexics: _targetLexics,
	$output: function($tag, babelute, oldBabelute, env) {
		oldBabelute ? dif($tag, babelute, oldBabelute, env) : render($tag, babelute, env);
		return babelute;
	},
	render: render,
	dif: dif,
	remove: remove,
	strategies: {
		render: renderActions,
		dif: difActions,
		remove: removeActions
	}
};



// Alternative (more optimised method for diffing tags and compounds wit babelutes as argument(s) and no change on others)
//
// if there is no change on non-babelutes arguments (or there is no non-babelutes arguments) : 
// we could  directly compare babelutes arguments without executing current lexem developpement.
// If there is some non-babelutes arguments changes : 
// we need to develop current lexem with included non-babelutes aguments as normal.
// (they will be compared through developpement)
/*

	ya moyen de difer juste les babelutes sans récursion : 

		fairecomme avant diff sur args avec catch babelute et shouldExpand

		if(! shouldExpend && babeluteS.length)
			==> Babelute.developOneDegree(lexem)
			==> dif (bi and obi)

 */
/*
don't forget :  babelute.parent = lexem.child;   (on tag's children babelute)

 function difArgs2($tag, args, oargs, env) {
	var shouldExpand = false, // say if we have seen changes between non-babelutes arguments
		babelutes = [];
	for (var i = 0, arg, len = args.length; i < len; ++i) {
		arg = args[i];
		if (arg && arg.__babelute__)
			babelutes.push({
				b: arg,
				ob: oargs[i]
			});
		else if (arg !== oargs[i]) { // simple reference check : need immutables
			shouldExpand = true;
			break;
		}
	}
	if (!shouldExpand && babelutes.length)
		for (var j = 0, lenj = babelutes.length, b, oldb; j < lenj; ++j) {
			b = babelutes[j].b;
			oldb = babelutes[j].ob;
			b.parent = oldb.parent;
			dif(oldb.parent ||  $tag, b, oldb, env);
			oldb._lexems = b._lexems;
		}
	return shouldExpand;
}*/
},{"../html":2,"babelute/lib/babelute":5}],4:[function(require,module,exports){
/**
 * @author Gilles Coomans
 * @licence MIT
 * @copyright 2016 Gilles Coomans
 */

// core class
var Babelute = require('./lib/babelute');
// lexics
require('./lib/lexicons');

module.exports = Babelute;
},{"./lib/babelute":5,"./lib/lexicons":6}],5:[function(require,module,exports){
/**
 * Babelute core Class and statics functions.
 *
 * A babelute is just a sentences (a chain of lexems with argument(s)) 
 * written with method chaining, (aka foo(1, true).bar('zoo', goo().foo()) )
 * and where lexems (each call - aka .myLexem(arg1, ...)) 
 * are simply kept in an array for further interpretations, 
 * in following object format : { lexic:'...', name:'...', args:[...] }.
 *
 * Absolutly nothing more.
 *
 * The Babelute Class is just the main helper for writing and holding babelute sentences. 
 *
 * @author Gilles Coomans
 * @licence MIT
 * @copyright 2016 Gilles Coomans
 */

var Babelute = function(lexems) {
		this.__babelute__ = 'default'; // current lexic
		this._lexems = lexems || [];
	},
	Lexem = Babelute.Lexem = function(lexic, name, args) {
		this.__babelutelexem__ = true;
		this.lexic = lexic;
		this.name = name;
		this.args = args;
	};

Babelute.prototype = {
	// add lexem to babelute
	_append: function(lexicName, name, args) {
		this._lexems.push(new Lexem(lexicName, name, args));
		return this;
	},
	/**********************************************************
	 ********************** DEFAULT LEXEMS ********************
	 **********************************************************/
	// conditional execution
	if: function(condition, babelute, elseBabelute) {
		return this._append('default', 'if', arguments);
	},
	// each output
	each: function(collection, callback) {
		return this._append('default', 'each', arguments);
	}
};

Lexem.prototype.log = function(title) {
	console.log(title || '', this.lexic, this.name, this.args);
};

module.exports = Babelute;

//
},{}],6:[function(require,module,exports){
/**
 * A FirstDegreeNode is just a Bablute that keeps any appended lexem at top logical level (that means that any compounded lexem (made with other lexems) is added as an atomic lexem).
 * 
 * A Babelute Document is a Babelute that you could edit. Think about a XML/HTML Document.
 * The aim is to allow full edition and construction of Babelute sentences.
 * (babelute node wrapping, insertBefore, prepend, query nodes, etc)
 * 
 * A FirstDegreeNode document, that holds others FirstDegreeNode as inner lexems, forms a valid babelute.
 * Every call on a FirstDegreeNode are just appended to lexems in object form (aka { name:myLexemName, args:[myArgs...] }).
 *
 * So it keeps things the more abstract possible. 
 * 
 * To became $outputable : it needs an additional translation to itself.
 * aka : bfd('myLexic').bla().bla()._translate('myLexic').$output(...)
 *
 * See docs for more infos
 */

var Babelute = require('./babelute'),
	Lexem = Babelute.Lexem,
	lexicsDico = {};

/********************
 * TRANSLATION
 ********************/

Babelute.prototype._translation = function(lexicName) {
	var lexic = getLexic(lexicName),
		b = new lexic.Cl();
	this._lexems.forEach(function(lexem) {
		var args = [];
		for (var i = 0, len = lexem.args.length; i < len; ++i)
			args.push(translateValue(lexicName, lexem.args[i]));
		if (this[lexem.name])
			this[lexem.name].apply(this, args);
		else
			this._lexems.push(new Lexem(lexem.lexic, lexem.name, args));
	}, b);
	return b;
}

function translateValue(lexicName, value) {
	if (!value)
		return value;
	if (value.__babelute__)
		return value._translation(lexicName);
	else if (typeof value === 'object') {
		// if (value.forEach)
		// 	return value.map(function(item) {
		// 		return translateValue(lexicName, item);
		// 	});
		// var obj = {};
		// for (var i in value)
		// 	obj[i] = translateValue(lexicName, value[i]);
		// return obj;
	} else return value;
}

/**
 * get new dedicated babelute handler that act on same aray of lexems (current one)
 * return new babelute specialised with lexicName
 */
Babelute.prototype._lexicon = function(lexicName) {
	var lexic = getLexic(lexicName),
		Cl = lexic.Cl,
		b = new Cl();
	b._lexems = this._lexems;
	return b;
};
/**
 * get new babelute handler of same type than current one (independant of current array of lexems)
 * return new babelute specialised with lexicName or current lexic
 */
Babelute.prototype._new = function(lexicName) {
	return initializer(lexicName ||  this.__babelute__ !== true ? this.__babelute__ : null);
};

/**
 * Add method(s) to specified lexic
 * @param  {String} lexicName  	the name of the lexic where happening method(s)
 * @param  {String | Array | Object} 	If is string : it's the name of the method. If is array of string : each string is the name of a logical atom method. If is an object : it's used as a map of methods.
 * @param  {Function} method    the method function. used only if methoName is a string.
 * @return {Babelute}   		Babelute for chaining
 */
function toLexic(lexicName, methodName, method) {
	var lexic = lexicsDico[lexicName] || extendLexic('default', lexicName).getLexic(lexicName);
	if (typeof methodName === 'object') {
		if (methodName.forEach) {
			// array of logical atoms. pure single _append
			methodName.forEach(function(methodName) {
				addLexem(lexic, lexicName, methodName);
			});
		} else {
			// map of methods
			for (var i in methodName)
				addLexem(lexic, lexicName, i, methodName[i]);
		}
	} else
		addLexem(lexic, lexicName, methodName, method);
	return Babelute;
}

function addLexem(lexic, lexicName, methodName, method) {
	var fdproto = lexic.FirstDegree.prototype;
	fdproto[methodName] = getFirstDegreeMethod(lexicName, methodName);
	lexic.Cl.prototype[methodName] = method || fdproto[methodName];
	addToInitializer(lexic, methodName);
}

// duplicate specified lexic to newName and add provided methods to it.
function extendLexic(lexicName, newName, methods) {
	initLexic(newName, getLexic(lexicName));
	if (methods)
		toLexic(newName, methods);
	return Babelute;
}

// return specified lexic.
function getLexic(lexicName) {
	var lexic = lexicsDico[lexicName];
	if (!lexic)
		throw new Error('Babelute : lexic not found : ' + lexicName);
	return lexic;
}

function createClass(lexicName, BaseClass) {
	var Cl = function() {
		BaseClass.call(this);
		this.__babelute__ = lexicName;
	};
	Cl.prototype = new BaseClass();
	return Cl;
}

function initLexic(lexicName, baseLexic) {
	var lexic = lexicsDico[lexicName] = {
		Cl: createClass(lexicName, (baseLexic && baseLexic.Cl) || Babelute),
		FirstDegree: createClass(lexicName, (baseLexic && baseLexic.FirstDegree) || BaseFirstDegree)
	};
	lexic.Instance = new lexic.Cl();
	lexic.initializer = {
		_empty: function() {
			return new lexic.Cl();
		}
	};
	if (baseLexic)
		for (var i in baseLexic.initializer)
			addToInitializer(lexic, i);
	return lexic;
}

// babelute initializer management

function addToInitializer(lexic, method) {
	lexic.initializer = lexic.initializer ||  {};
	lexic.fdInitializer = lexic.fdInitializer ||  {};
	lexic.initializer[method] = function() {
		var instance = new lexic.Cl();
		return instance[method].apply(instance, arguments);
	};
	lexic.fdInitializer[method] = function() {
		var instance = new lexic.FirstDegree();
		return instance[method].apply(instance, arguments);
	};
}

// Babelute initializer provider
function initializer(lexicName) {
	return getLexic(lexicName || 'default').initializer;
}

function firstDegreeInitializer(lexicName) {
	return getLexic(lexicName || 'default').fdInitializer;
}

/**
 * DEFAULT FIRST DEGREE BABELUTE INIT and DEFAULT INITIALIZER
 */

function BaseFirstDegree(lexems) {
	Babelute.call(this, lexems);
	this.__babelute__ = 'default';
}
BaseFirstDegree.prototype = new Babelute();
BaseFirstDegree.prototype._babelute = function(lexicName) {
	var lexic = Babelute.getLexic(lexicName),
		b = new lexic.FirstDegree();
	b._lexems = this._lexems;
	return b;
};
lexicsDico['default'] = {
	Cl: Babelute,
	FirstDegree: BaseFirstDegree
};
for (var i in Babelute.prototype) {
	if (i[0] === '_')
		continue;
	BaseFirstDegree.prototype[i] = getFirstDegreeMethod('default', i);
	addToInitializer(lexicsDico['default'], i);
}
//_________ UTILS

function getFirstDegreeMethod(lexicName, methodName) {
	return function() {
		this._lexems.push(new Lexem(lexicName, methodName, arguments));
		return this;
	};
}

// parse lexicName:methodName string format and return method from lexic
function execMethod(babelute, req, args) {
	var splitted = req.split(':'),
		lexicName = splitted[0],
		methodName = splitted[1],
		lexic = getLexic(lexicName);
	if (!lexic.Instance[methodName])
		throw new Error('Babelute : method not found : ' + req);
	lexic.Instance[methodName].apply(babelute, args);
}

Babelute.getLexic = getLexic;
Babelute.FirstDegree = BaseFirstDegree;
Babelute.lexics = lexicsDico;
Babelute.initializer = initializer;
Babelute.firstDegreeInitializer = firstDegreeInitializer;
Babelute.execMethod = execMethod;
Babelute.toLexic = toLexic;
Babelute.extendLexic = extendLexic;
Babelute.b = function(lexicName) {
	if (lexicName)
		return new(getLexic(lexicName).Cl)();
	return new Babelute();
};

// use a babelute (concat its lexems to local ones)
Babelute.prototype._use = function(babelute /* could be a string in "lexicName:methodName" format */ /*, ...args */ ) {
	if (!babelute)
		return this;
	var args = [].slice.call(arguments, 1);
	if (typeof babelute === 'string')
		execMethod(this, babelute, args);
	else if (babelute.__babelute__)
		this._lexems = this._lexems.concat(babelute._lexems);
	else // is function
		babelute(this._lexems, args);
	return this;
};
Babelute.expandOneDegreeLexem = function(lexem) {
	var lexic = getLexic(lexem.lexic);
	return lexem.developped = lexic.Instance[lexem.name].apply(new lexic.FirstDegree(), lexem.args);
};

module.exports = lexicsDico;

//
},{"./babelute":5}]},{},[1])(1)
});